<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>RTuinOS: rtos.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RTuinOS&#160;<span id="projectnumber">0.3</span></div>
   <div id="projectbrief">Small Scale RTOS for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('rtos_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>rtos.c File Reference</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &lt;arduino.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="rtos__assert_8h_source.html">rtos_assert.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="rtos_8h_source.html">rtos.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a20cc43d0046b2ac33d6880bd621a19c2">IDLE_TASK_ID</a>&#160;&#160;&#160;(RTOS_NO_TASKS)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a42b766a4e744a480b8349bc1be22cf1d">UNUSED_STACK_PATTERN</a>&#160;&#160;&#160;0x29</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a7e23ea17d713aa36beef2571a72d177e">PUSH_CONTEXT_ONTO_STACK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a0bfd1176ef3da1b6a56f8f6346756420">PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a775845087a4ea091911dce4173b49377">POP_CONTEXT_FROM_STACK</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ac884c3a1ef50da2f7c61a3588b54c8f1">SWITCH_CONTEXT</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ab50466613b5d30ab2e75073e7594c28f">PUSH_RET_CODE_OF_CONTEXT_SWITCH</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void RTOS_DEFAULT_FCT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ad1c5008c324111a1df14ff7e7ae341da">rtos_enableIRQTimerTic</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile RTOS_NAKED_FCT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#aa1bf6374a8db8a9653cbe9c468e26889">rtos_setEvent</a> (uint16_t eventVec)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile uint16_t RTOS_NAKED_FCT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a3655251a2710361d71c85c33775265b4">rtos_waitForEvent</a> (uint16_t eventMask, bool all, uintTime_t timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#aa9863feea1785d4d60073a35876e1d5c">ISR</a> (RTOS_ISR_SYSTEM_TIMER_TIC, ISR_NAKED)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ae2492b9573d7bf62a38dfa68dc85de2b">rtos_getTaskOverrunCounter</a> (uint8_t idxTask, bool doReset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a54ca7c825941b0d17877db45d2b4c662">rtos_getStackReserve</a> (uint8_t idxTask)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#af4d070278dab5d7c12cebb7ce8e4a30a">rtos_initializeTask</a> (uint8_t idxTask, <a class="el" href="rtos_8h.html#a3e12c5d9135209b870ca71628179beb3">rtos_taskFunction_t</a> taskFunction, uint8_t prioClass, uint8_t *const pStackArea, uint16_t stackSize, uint16_t startEventMask, bool startByAllEvents, uintTime_t startTimeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#ac8b1fae05c844e38b6d93fab56597ce7">rtos_initRTOS</a> (void)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#aed225646fe49a53d2a6031c0a99e57cf">_tmpVarAsmToC_u16</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8c.html#a28dcbedd17c277ec7b25de1694539131">_tmpVarCToAsm_u16</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Implementation of a Real Time Operating System for the Arduino Mega board in the Arduino environment 1.0.1.<br/>
 The implementation is dependent on the board (the controller) and the GNU C++ compiler (thus the release of the Arduino environment) but should be easily portable to other boards and Arduino releases. See manual for details.</p>
<p>Copyright (C) 2012 Peter Vranken (mailto:<a href="mailto:Peter_Vranken@Yahoo.de">Peter_Vranken@Yahoo.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see &lt;<a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>&gt;. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a20cc43d0046b2ac33d6880bd621a19c2"></a><!-- doxytag: member="rtos.c::IDLE_TASK_ID" ref="a20cc43d0046b2ac33d6880bd621a19c2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IDLE_TASK_ID&#160;&#160;&#160;(RTOS_NO_TASKS)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The ID of the idle task. The ID of a task is identical with the index into the task array. </p>

</div>
</div>
<a class="anchor" id="a42b766a4e744a480b8349bc1be22cf1d"></a><!-- doxytag: member="rtos.c::UNUSED_STACK_PATTERN" ref="a42b766a4e744a480b8349bc1be22cf1d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNUSED_STACK_PATTERN&#160;&#160;&#160;0x29</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A pattern byte, which is used as prefill byte of any task stack area. A simple and unexpensive stack usage check at runtime can be implemented by looking for up to where this pattern has been destroyed. Any value which is not the null and which is improbable to be a true stack contents byte can be used - whatever this value might be. </p>

</div>
</div>
<a class="anchor" id="a7e23ea17d713aa36beef2571a72d177e"></a><!-- doxytag: member="rtos.c::PUSH_CONTEXT_ONTO_STACK" ref="a7e23ea17d713aa36beef2571a72d177e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_CONTEXT_ONTO_STACK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="rtos_8c.html#a0bfd1176ef3da1b6a56f8f6346756420">PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK</a>;         \
    <span class="keyword">asm</span> <span class="keyword">volatile</span>                                    \
    ( <span class="stringliteral">&quot;push r24 \n\t&quot;</span>                               \
      <span class="stringliteral">&quot;push r25 \n\t&quot;</span>                               \
    );
</pre></div><p>An important code pattern, which is used in every interrupt routine, which can result in a context switch. The CPU context except for the program counter is saved by pushing it onto the stack of the given context. The program counter is not explicitly saved: This code pattern needs to be used at the very beginning of a function so that the PC has been pushed onto the stack just before by the call of this function.<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function which uses this pattern must not be inlined, otherwise the PC would not be part of the saved context and the system would crash when trying to return to this context the next time! </dd>
<dd>
This pattern needs to be changed only in strict accordance with the counterpart pattern, which pops the context from a stack back into the CPU. Both pattern needs to be the inverse of each other. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bfd1176ef3da1b6a56f8f6346756420"></a><!-- doxytag: member="rtos.c::PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK" ref="a0bfd1176ef3da1b6a56f8f6346756420" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_CONTEXT_WITHOUT_R24R25_ONTO_STACK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An important code pattern, which is used in every suspend command. The CPU context execpt for the register pair r24/r25 is saved by pushing it onto the stack of the given context. (Exception program counter: see macro <a class="el" href="rtos_8c.html#a7e23ea17d713aa36beef2571a72d177e">PUSH_CONTEXT_ONTO_STACK</a>.)<br/>
 When returning to a context which had become un-due by invoking one of the suspend commands, the restore context should still be done with the other macro <a class="el" href="rtos_8c.html#a775845087a4ea091911dce4173b49377">POP_CONTEXT_FROM_STACK</a>. However, before using this macro, the return code of the suspend command needs to be pushed onto the stack so that it is loaded into the CPU's register pair r24/r25 as part of macro <a class="el" href="rtos_8c.html#a775845087a4ea091911dce4173b49377">POP_CONTEXT_FROM_STACK</a>. </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function which uses this pattern must not be inlined, otherwise the PC would not be part of the saved context and the system would crash when trying to return to this context the next time! </dd>
<dd>
This pattern needs to be changed only in strict accordance with the counterpart pattern, which pops the context from a stack back into the CPU. </dd></dl>

</div>
</div>
<a class="anchor" id="a775845087a4ea091911dce4173b49377"></a><!-- doxytag: member="rtos.c::POP_CONTEXT_FROM_STACK" ref="a775845087a4ea091911dce4173b49377" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define POP_CONTEXT_FROM_STACK</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An important code pattern, which is used in every interrupt routine (including the suspend commands, which can be considered pseudo-software interrupts). The CPU context except for the program counter is restored by popping it from the stack of the given context. The program counter is not popped: This code pattern needs to be used at the very end of a function so that the PC will be restored by the machine return command (ret or reti).<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function which uses this pattern must not be inlined, otherwise the PC would not be part of the restored context and the system would crash. </dd>
<dd>
This pattern needs to be changed only in strict accordance with the counterpart patterns, which push the context onto the stack. The pattern need to be the inverse of each other. </dd></dl>

</div>
</div>
<a class="anchor" id="ac884c3a1ef50da2f7c61a3588b54c8f1"></a><!-- doxytag: member="rtos.c::SWITCH_CONTEXT" ref="ac884c3a1ef50da2f7c61a3588b54c8f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SWITCH_CONTEXT</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment">{                                                                                           \
    <span class="comment">/* Switch the stack pointer to the (saved) stack pointer of the new active task. */</span>     \
    <a class="code" href="rtos_8c.html#a28dcbedd17c277ec7b25de1694539131">_tmpVarCToAsm_u16</a> = _pActiveTask-&gt;stackPointer;                                         \
    <span class="keyword">asm</span> <span class="keyword">volatile</span>                                                                            \
    ( <span class="stringliteral">&quot;in r0, __SP_L__ /* Save current stack pointer at known, fixed location */ \n\t&quot;</span>      \
      <span class="stringliteral">&quot;sts _tmpVarAsmToC_u16, r0 \n\t&quot;</span>                                                      \
      <span class="stringliteral">&quot;in r0, __SP_H__ \n\t&quot;</span>                                                                \
      <span class="stringliteral">&quot;sts _tmpVarAsmToC_u16+1, r0 \n\t&quot;</span>                                                    \
      <span class="stringliteral">&quot;lds r0, _tmpVarCToAsm_u16 \n\t&quot;</span>                                                      \
      <span class="stringliteral">&quot;out __SP_L__, r0 /* Write l-byte of new stack pointer content */ \n\t&quot;</span>               \
      <span class="stringliteral">&quot;lds r0, _tmpVarCToAsm_u16+1 \n\t&quot;</span>                                                    \
      <span class="stringliteral">&quot;out __SP_H__, r0 /* Write h-byte of new stack pointer content */ \n\t&quot;</span>               \
    );                                                                                      \
    _pSuspendedTask-&gt;stackPointer = <a class="code" href="rtos_8c.html#aed225646fe49a53d2a6031c0a99e57cf">_tmpVarAsmToC_u16</a>;                                      \
                                                                                            \
}
</pre></div><p>An important code pattern, which is used in every interrupt routine (including the suspend commands, which can be considered pseudo-software interrupts). The code performs the actual task switch by saving the current stack pointer in a location owned by the left task and loading the stack pointer from a location owned by the new task (where its stack pointer value had been saved at initialization time or the last time it became inactive.).<br/>
 The code fragment then decides whether the new task had been inactivated by a timer or application interrupt or by a suspend command. In the latter case the return value of the suspend command is put onto the stack. From there it'll be loaded into the CPU when ending the interrupt routine.<br/>
 Side effects: The left task and the new task are read from the global variables _pSuspendedTask and _pActiveTask.<br/>
 Prerequisites: The use of the macro needs to be followed by a use of macro PUSH_RET_CODE_OF_SWITCH_CONTEXT. (Both macros have not been yoined to a single one only for sake of comprehensibility of the code using the code patterns.)<br/>
 The routine depends on a reset global interrupt flag.<br/>
 The implementation must be compatible with a naked function. In particular, it must not define any local data! </p>

</div>
</div>
<a class="anchor" id="ab50466613b5d30ab2e75073e7594c28f"></a><!-- doxytag: member="rtos.c::PUSH_RET_CODE_OF_CONTEXT_SWITCH" ref="ab50466613b5d30ab2e75073e7594c28f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PUSH_RET_CODE_OF_CONTEXT_SWITCH</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>An important code pattern, which is used in every interrupt routine (including the suspend commands, which can be considered pseudo-software interrupts). Immediately after a context switch, the code fragment decides whether the task we had switched to had been inactivated by a timer or application interrupt or by a suspend command. (Only) in the latter case the return value of the suspend command is put onto the stack. From there it'll be loaded into the CPU when ending the interrupt routine.<br/>
 Side effects: The new task is read from the global variable _pActiveTask.<br/>
 Prerequisites: The use of the macro needs to be preceeded by a use of macro SWITCH_CONTEXT.<br/>
 The routine depends on a reset global interrupt flag.<br/>
 The implementation must be compatible with a naked function. In particular, it must not define any local data! </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad1c5008c324111a1df14ff7e7ae341da"></a><!-- doxytag: member="rtos.c::rtos_enableIRQTimerTic" ref="ad1c5008c324111a1df14ff7e7ae341da" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_enableIRQTimerTic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start the interrupt which clocks the system time. Timer 2 is used as interrupt source with a period time of about 2 ms or a frequency of 490.1961 Hz respectively.<br/>
 This is the default implementation of the routine, which can be overloaded by the application code if another interrupt or other interrupt settings should be used. </p>

<p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>It is also possible to do specific initialization of any other available timer here and to enable the related interrupt. In which case you have to alter the name of the interrupt vector in use. Modify <a class="el" href="rtos_8config_8template_8h.html#ad4a77dc2ff9b06fc8e39ed35e768c0ae">RTOS_ISR_SYSTEM_TIMER_TIC</a> to do so. </dd></dl>
</p>

</div>
</div>
<a class="anchor" id="aa1bf6374a8db8a9653cbe9c468e26889"></a><!-- doxytag: member="rtos.c::rtos_setEvent" ref="aa1bf6374a8db8a9653cbe9c468e26889" args="(uint16_t eventVec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void rtos_setEvent </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eventVec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A task (including the idle task) may post an event. The event is broadcasted to all suspended tasks which are waiting for it. An event is not saved beyond that. If a task suspends and starts waiting for an event which has been posted by another task just before, it'll wait forever and never be resumed.<br/>
 The posted event may release another task, which may be of higher priority as the event posting task. In this case <em>setEvent</em> will cause a task switch. The calling task stays due but stops to be the active task. It does not become suspended (this is why even the idle task may call this function). The activated task will resume by coming out of the suspend command it had been invoked to wait for this event. The return value of this suspend command will then tell about the event set here.<br/>
 If no task of higher priority is released by the posted event the calling task will be continued immediately after execution of this method. In this case <em>setEvent</em> behaves like any ordinary sub-routine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventVec</td><td>A bit vector of posted events. Known events are defined in <a class="el" href="rtos_8h.html">rtos.h</a>. The timer events RTOS_EVT_ABSOLUTE_TIMER and RTOS_EVT_DELAY_TIMER cannot be posted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>uint16_t <a class="el" href="rtos_8h.html#a3655251a2710361d71c85c33775265b4">rtos_waitForEvent(uint16_t, bool, uintTime_t)</a> </dd></dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It is absolutely essential that this routine is implemented as naked and noinline. See <a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html</a> for details </dd>
<dd>
In optimization level 0 GCC has a problem with code generation for naked functions. See function <a class="el" href="rtos_8h.html#a2737105bf5c4cfcb141495e068a1f9ac">rtos_suspendTaskTillTime</a> for details. </dd>
<dd>
The implementation of this function is reused on machine code level by the implementation of the application interrupt service routines <em>ISR(RTOS_ISR_USER_nn)</em>. This function needs to be maintained in strict accordance with the implementation of the ISRs. </dd></dl>

</div>
</div>
<a class="anchor" id="a3655251a2710361d71c85c33775265b4"></a><!-- doxytag: member="rtos.c::rtos_waitForEvent" ref="a3655251a2710361d71c85c33775265b4" args="(uint16_t eventMask, bool all, uintTime_t timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t rtos_waitForEvent </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>eventMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Suspend the current task (i.e. the one which invokes this method) until a specified combination of events occur.<br/>
 A task is suspended in the instance of calling this method. It specifies a list of events. The task becomes due again, when either the first one or all of the specified events have been posted by other tasks.<br/>
 The idle task can't be suspended. If it calls this function a crash would be the immediate result. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The set of actually resuming events is returned as a bit vector which corresponds bitwise to eventMask. See <em><a class="el" href="rtos_8h.html">rtos.h</a></em> for a list of known events. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">eventMask</td><td>The bit vector of events to wait for. Needs to include either the delay timer event <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> or <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a>, if a timeout is required, but not both of them.<br/>
 The normal use case will probably be the delay timer. However, a regular task may also specify the absolute timer with the next regular task time as parameter so that it surely becomes due outermost at its usual task time. </td></tr>
    <tr><td class="paramname">all</td><td>If false, the task is made due as soon as the first event mentioned in <em>eventMask</em> is seen.<br/>
 If true, the task is made due only if all events are posted - except for the timer events, which are still OR combined. If you say "all" but the event mask contains either <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> or <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a>, the task will resume when either the timer elapsed or when all other events in the mask were seen. </td></tr>
    <tr><td class="paramname">timeout</td><td>If <em>eventMask</em> contains <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a>: The number of system timer tics from now on until the timeout elapses. One should be aware of the resolution of any timing being the tic of the system timer. A timeout of n may actually mean any delay in the range n..n+1 tics.<br/>
 Even specifying 0 will suspend the task a short time and give others the chance to become active - particularly other tasks belonging to the same priority class.<br/>
 If <em>eventMask</em> contains <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a>: The absolute time the task becomes due again at latest. The time designation is relative; it refers to the last recent absolute time at which this task had been resumed. See <a class="el" href="rtos_8h.html#a2737105bf5c4cfcb141495e068a1f9ac">rtos_suspendTaskTillTime</a> for details.<br/>
 If neither <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> nor <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a> is set in the event mask, this parameter should be zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>It is absolutely essential that this routine is implemented as naked and noinline. See <a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html</a> for details </dd>
<dd>
GCC doesn't create a stack frame for naked functions. For normal functions, the calling parameter of the function is stored in such a stack frame. In the combination naked and having local function parameters, GCC has a problem when generating code without optimization: It doesn't generate a stack frame but still does save the local parameter into the (not existing) stack frame as very first assembly operation of the function code. There's absolutely no work around; when the earliest code, we can write inside the function is executed, the stack is already corrupted in a harzardous way. A crash is unavoidable.<br/>
 A (less helpful) discussion of the issue can be found at <a href="http://lists.gnu.org/archive/html/avr-gcc-list/2012-08/msg00014.html.">http://lists.gnu.org/archive/html/avr-gcc-list/2012-08/msg00014.html.</a><br/>
 To avoid this problem we forbid to compile the code with optimization off. Nonetheless, who will ever know or understand under which circumstances, e.g. which combination of optimization flags, GCC will again generate this crash-code. This issue remains a severe risk! Consequently, at any change of a compiler setting you will need to inspect the assembly listing file and double-check that it is proper with respect of using (better not using) the stack frame for this function (and rtos_setEvent).<br/>
 Another idea would be the implementation of this function completely in assembly code. Doing so, we have the new problem of calling assembly code as C functions. Find an example of how to do in <a href="file:///M:/SVNMainRepository/Arduino/RTuinOS/trunk/RTuinOS/code/RTOS/rtos.c,">file:///M:/SVNMainRepository/Arduino/RTuinOS/trunk/RTuinOS/code/RTOS/rtos.c,</a> revision 215. </dd></dl>

</div>
</div>
<a class="anchor" id="aa9863feea1785d4d60073a35876e1d5c"></a><!-- doxytag: member="rtos.c::ISR" ref="aa9863feea1785d4d60073a35876e1d5c" args="(RTOS_ISR_SYSTEM_TIMER_TIC, ISR_NAKED)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ISR </td>
          <td>(</td>
          <td class="paramtype">RTOS_ISR_SYSTEM_TIMER_TIC&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ISR_NAKED&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Each call of this function cyclically increments the system time of the kernel by one.<br/>
 Incrementing the system timer is an important system event. The routine will always include an inspection of all suspended tasks, whether they could become due again. The cycle time of the system time is low (typically implemented as 0..255) and determines the maximum delay time or timeout for a task which suspends itself and the ratio of the task periods of the fastest and the slowest regular task. Furthermore it determines the reliability of task overrun recognition. Task overrun events in the magnitude of half the cycle time won't be recognized as such.<br/>
 The unit of the time is defined only by the it triggering source and doesn't matter at all for the kernel. The time even don't need to be regular.<br/>
 </p>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The function needs to be called by an interrupt and can easily end with a context change, i.e. the interrupt will return to another task as that it had interrupted. </dd>
<dd>
The connected interrupt is defined by macro <a class="el" href="rtos_8config_8template_8h.html#ad4a77dc2ff9b06fc8e39ed35e768c0ae">RTOS_ISR_SYSTEM_TIMER_TIC</a>. This interrupt needs to be disabled/enabled by the implementation of <em>enterCriticalSection</em> and <em>leaveCriticalSection</em>. </dd>
<dd>
The cycle time of the system time can be influenced by the typedef of uintTime_t. Find a discussion of pros and cons at the location of this typedef. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>bool onTimerTic(void) </dd>
<dd>
<a class="el" href="rtos_8config_8template_8h.html#acf24026fc76a744b3bfeb63b9277cb58">rtos_enterCriticalSection</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2492b9573d7bf62a38dfa68dc85de2b"></a><!-- doxytag: member="rtos.c::rtos_getTaskOverrunCounter" ref="ae2492b9573d7bf62a38dfa68dc85de2b" args="(uint8_t idxTask, bool doReset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t rtos_getTaskOverrunCounter </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idxTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doReset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the current value of the overrun counter of a given task.<br/>
 The value is a limited (i.e. it won't cycle around) 8 Bit counter. This is considered satisfying as any task overrun is a kind of error and should not happen in a real application (with other words: even a Boolean information would maybe enough). Furthermore, if a larger range is required, one can regularly ask for this information, accumulate it and reset the value here to zero at the same time.<br/>
 The function may be called from a task or from the idle task. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Get the current value of the overrun counter. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idxTask</td><td>The index of the task the overrun counter of which is to be returned. The index is the same as used when initializing the tasks (see rtos_initializeTask). </td></tr>
    <tr><td class="paramname">doReset</td><td>Boolean flag, which tells whether to reset the value.<br/>
 Caution, when setting this to true, reading and resetting the value needs to become an atomic operation, which requires a critical section. This is significantly more expensive than just reading the value and it globally enables the interrupts finally. Therefore this call may destroy a surrounding critical section. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="rtos_8c.html#af4d070278dab5d7c12cebb7ce8e4a30a">rtos_initializeTask()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54ca7c825941b0d17877db45d2b4c662"></a><!-- doxytag: member="rtos.c::rtos_getStackReserve" ref="a54ca7c825941b0d17877db45d2b4c662" args="(uint8_t idxTask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t rtos_getStackReserve </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idxTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compute how many bytes of the stack area of a task are still unsued. If the value is requested after an application has been run a long while and has been forced to run through all its paths many times, it may be used to optimize the static stack allocation of the task. The function is useful only for diagnosis purpose as there's no chance to dynamically increase or decrease the stack area at runtime.<br/>
 The function may be called from a task or from the idle task.<br/>
 The alogorithm is as follows: The unused part of the stack is initialized with a specific pattern byte. This routine counts the number of subsequent pattern bytes down from the top of the stack area. This number is returned.<br/>
 The returned result must not be trusted too much: It could of course be that a pattern byte is found not because of teh initialization but because it has been pushed onto the stack - in which case the return value is too great (too optimistic) by one. The probability that this happens is significanly greater than zero. The chance that two pattern bytes had been pushed is however much less and the probability of three, four, five such bytes in sequence is neglectable. (Except the irrelevant case you initialize an automatic array variable with all pattern bytes.) Any stack size optimization based on this routine should therefore subtract e.g. five bytes from the returned reserve and diminish the stack outermost by this modified value.<br/>
 Be careful with stack size optimization based on this routine: Even if the application ran a long time there's a non-zero probability that there has not yet been a system timer interrupt in the very instance that the code of the task of interest was busy in the deepest nested sub-routine, i.e. when having the largest stack consumption. A good suggestion is to have another 36 Byte of reserve - this is the stack consumption if an interrupt occurs.<br/>
 Recipe: Run your application a long time, ensure that it ran through all paths, get the stack reserve from this routine, subtract 5+36 Byte and diminish the stack by this value. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of still unsused stack bytes. See function description for details. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idxTask</td><td>The index of the task the stack usage has to be investigated for. The index is the same as used when initializing the tasks (see rtos_initializeTask). </td></tr>
  </table>
  </dd>
</dl>
<dl class="remark"><dt><b>Remarks:</b></dt><dd>The computation is a linear search for the first non-pattern byte and thus relatively expensive. It's suggested to call it only in some specific diagnosis compilation or occasionally from the idle task. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="rtos_8c.html#af4d070278dab5d7c12cebb7ce8e4a30a">rtos_initializeTask()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af4d070278dab5d7c12cebb7ce8e4a30a"></a><!-- doxytag: member="rtos.c::rtos_initializeTask" ref="af4d070278dab5d7c12cebb7ce8e4a30a" args="(uint8_t idxTask, rtos_taskFunction_t taskFunction, uint8_t prioClass, uint8_t *const pStackArea, uint16_t stackSize, uint16_t startEventMask, bool startByAllEvents, uintTime_t startTimeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_initializeTask </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>idxTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rtos_8h.html#a3e12c5d9135209b870ca71628179beb3">rtos_taskFunction_t</a>&#160;</td>
          <td class="paramname"><em>taskFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prioClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *const&#160;</td>
          <td class="paramname"><em>pStackArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>startEventMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>startByAllEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintTime_t&#160;</td>
          <td class="paramname"><em>startTimeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the contents of a single task object.<br/>
 This routine needs to be called from within setup() once for each task. The number of tasks has been defined by the application using <a class="el" href="rtos_8config_8template_8h.html#a9375e1b99d1360af097706deed2dd957">RTOS_NO_TASKS</a> but the array of this number of task objects is still empty. The system will crash if this routine is not called properly for each of the tasks before the RTOS actually starts.<br/>
 This function must never be called outside of setup(). A crash would result otherwise. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">idxTask</td><td>The index of the task in the range 0..RTOS_NO_TASKS-1. The order of tasks barely matters. </td></tr>
    <tr><td class="paramname">taskFunction</td><td>The task function as a function pointer. It is used once and only once: The task function is invoked the first time the task becomes active and must never end. A return statement would cause an immediate reset of the controller. </td></tr>
    <tr><td class="paramname">prioClass</td><td>The priority class this task belongs to. Priority class 255 has the highest possible priority and the lower the value the lower the priority. </td></tr>
    <tr><td class="paramname">timeRoundRobin</td><td>The maximum time a task may be activated if it is operated in round-robin mode. The range is 1..max_value(<em>uintTime_t</em>).<br/>
 Specify a maximum time of 0 to switch round robin mode off for this task.<br/>
 Remark: Round robin like behavior is given only if there are several tasks in the same priority class and all tasks of this class have the round-robin mode activated. Otherwise it's just the limitation of execution time for an individual task.<br/>
 This parameter is available only if <a class="el" href="rtos_8config_8template_8h.html#a40d0df06f67d8a73574879217d9ea34c">RTOS_ROUND_ROBIN_MODE_SUPPORTED</a> is set to <a class="el" href="rtos_8h.html#af0db50dba4d0026d470641610de9b624">RTOS_FEATURE_ON</a>. </td></tr>
    <tr><td class="paramname">pStackArea</td><td>The pointer to the preallocated stack area of the task. The area needs to be available all the RTOS runtime. Therefore dynamic allocation won't pay off. Consider to use the address of any statically defined array. There's no alignment constraint. </td></tr>
    <tr><td class="paramname">stackSize</td><td>The size in Byte of the memory area <em>*pStackArea</em>, which is reserved as stack for the task. Each task may have an individual stack size. </td></tr>
    <tr><td class="paramname">startEventMask</td><td>The condition under which the task becomes due the very first time is specified in the same way as at runtime when using the suspend command rtos_waitForEvent: A set of events to wait for is specified, the Boolean information if any event will activate the task or if all are required and finally a timeout in case no such events would be posted.<br/>
 This parameter specifies the set of events as a bit vector. </td></tr>
    <tr><td class="paramname">startByAllEvents</td><td>If true, all specified events (except for a timer event) must be posted before the task is activated. Otherwise the first event belonging to the specified set will activate the task. See rtos_waitForEvent for details. </td></tr>
    <tr><td class="paramname">startTimeout</td><td>The task will be started at latest after <em>startTimeout</em> system timer tics if only the event <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> is in the set of specified events. If none of the timer events <a class="el" href="rtos_8h.html#ad1826c27715466493d50f3266ecd9cd9">RTOS_EVT_DELAY_TIMER</a> and <a class="el" href="rtos_8h.html#a2c10db7141dcec5eeb56c29cd0ac5fe8">RTOS_EVT_ABSOLUTE_TIMER</a> are set in <em>startEventMask</em>, the task will not be activated by a time condition. Do not set both timer events at once! See rtos_waitForEvent for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>void <a class="el" href="rtos_8h.html#ac8b1fae05c844e38b6d93fab56597ce7">rtos_initRTOS(void)</a> </dd>
<dd>
uint16_t <a class="el" href="rtos_8h.html#a3655251a2710361d71c85c33775265b4">rtos_waitForEvent(uint16_t, bool, uintTime_t)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac8b1fae05c844e38b6d93fab56597ce7"></a><!-- doxytag: member="rtos.c::rtos_initRTOS" ref="ac8b1fae05c844e38b6d93fab56597ce7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_initRTOS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Application called initialization of RTOS.<br/>
 Most important is the application handled task information. A task is characterized by several static settings which need to be preset by the application. To save ressources, a standard situation will be the specification of all relevant settings at compile time in the initializer expression of the array definition. The array is declared extern to enable this mode.<br/>
 The application however also has the chance to provide this information at runtime. Early in the execution of this function a callback <em>setup</em> into the application is invoked. If the application has setup everything as a compile time expression, the callback may simply contain a return.<br/>
 The callback <em>setup</em> is invoked before any RTOS related interrupts have been initialized, the routine is executed in the same context as and as a substitute of the normal Arduino setup routine. The implementation can be made without bothering with interrupt inhibition or data synchronization considerations. Furthermore it can be used for all the sort of things you've ever done in Arduino's setup routine.<br/>
 After returning from <em>setup</em> all tasks defined in the task array are made due. The main interrupt, which clocks the RTOS system time is started and will immediately make the very task the active task which belongs to the highest priority class and which was found first (i.e. in the order of rising indexes) in the task array. The system is running.<br/>
 No idle task is specified in the task array. The idle task is implicitly defined and implemented as the external function <em>loop</em>. To stick to Arduino's convention (and to give the RTOS the chance to benefit from idle as well) <em>loop</em> is still implemented as such: You are encouraged to return from <em>loop</em> after doing things. RTOS will call <em>loop</em> again as soon as it has some time left.<br/>
 As for the original Arduino code, <em>setup</em> and <em>loop</em> are mandatory, global functions.<br/>
 This routine is not called by the application but in C's main function. Your code seems to start with setup and seems then to branch into either <em>loop</em> (the idle task) or any other of the tasks defined by your application.<br/>
 This function never returns. No task must ever return, a reset will be the immediate consequence. Your part of the idle task, function <em>loop</em>, may and should return, but the actual idle task as a whole won't terminate neither. Instead it'll repeat to call <em>loop</em>. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="aed225646fe49a53d2a6031c0a99e57cf"></a><!-- doxytag: member="rtos.c::_tmpVarAsmToC_u16" ref="aed225646fe49a53d2a6031c0a99e57cf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t <a class="el" href="rtos_8c.html#aed225646fe49a53d2a6031c0a99e57cf">_tmpVarAsmToC_u16</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary data, internally used to pass information between assembly and C code. </p>

</div>
</div>
<a class="anchor" id="a28dcbedd17c277ec7b25de1694539131"></a><!-- doxytag: member="rtos.c::_tmpVarCToAsm_u16" ref="a28dcbedd17c277ec7b25de1694539131" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint16_t <a class="el" href="rtos_8c.html#a28dcbedd17c277ec7b25de1694539131">_tmpVarCToAsm_u16</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Temporary data, internally used to pass information between assembly and C code. </p>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="rtos_8c.html">rtos.c</a>      </li>
      <li class="footer">Generated on Thu Nov 8 2012 21:29:03 for RTuinOS by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
