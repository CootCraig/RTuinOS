Timer: Is also resolution for delay and waitForEvent. If run-time optimal
(tic=fastest task time) than the fastest task has no chance to use other
delay than with limit to next regular task due time

Event ISRs (incl. system time tic generation): Always need to save
complete context as it normally triggers a context switch. By machine code
it could be approriate to save it conditionally and in parts if the ISR
does some preparatory work and triggers an event only under conditions,
which itself defines. E.g. a keyboard read routine, which reports a key
touched event only after doing some debouncing in a series of ISR
invokations (state machine). Only if the event is set, all other registers
(which are not used by the ISR itself) are saved, before the event setting
API function of the RTOS is invoked.

The context switch may enable global interrupts first to not block high
priority interrupts. How to do and rules: Those ISRs must not trigger an
event which could result in a context switch. Possible e.g. for I/O
handling with high responsiveness. Initialition and feedback can only be
done in a normal task not using the RTOS events. 
  Double check if timer0 used by Arduino for millis etc. is an example.

Explain cli/sei versus enterLeaveCriticalSection: All interrupts are
locked or only the task switch causing one.

Tasks can be interrupted only by tasks of higher priority. If round robin
is implemented and activated, it may also be interrupted by tasks of same
priority class. Those and only those tasks which share data with tasks
which may interrupt them because of the rules before, need to apply calls
of enter/leaveCriticalSection to protect the access to this data.

Enter/leaveCriticalSection is part of the code adaptations when binding a
new interrupt to an existing event. ECS/LCS need to lock all interrupts
which possibly can cause a task switch - but no other interrupts.
  Example: producer-consumer model ADC: Free-running mode, interrupt on
conversion completed sets event. Task waiting for event with high priority
will read the result and switch the channel. It'll than do the
anti-aliasing filtering. The time-triggered slow task reads the filter
output (and does implicitly do the downsampling this way).

Idle task may set an event but may not suspend in any way. If it sets an
event it can be sure that the awaked task has completed all related data
processing until idle gets reactivated again. Therefore, a
producer-consumer solution can be implemented with a single event as
access synchronization, no ECS/LCS needs to be applied. (Explain why and
generalize this idea to any pair of tasks of different priority classes.)