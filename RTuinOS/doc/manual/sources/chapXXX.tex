\chapter{About \rtos{}}
\label{secAbout}

\rtos{} is a small real time operating system (RTOS) for the Arduino
environment. It is simple to use and fits well into the existing Arduino
code environment. It adds the concept of pseudo-parallel execution threads
to your sketches. These threads may be preemptive or non-premptive.
Deliberate, cooperative switching between the tasks is supported or time
based switching. Events can be sent and received by tasks as a simple kind
of communication.

\rtos{} is provided as a single source code file which is compiled together
with your other code, which now becomes an \rtos-application. In the most
simple case, if you do not define any task, your application will strongly
resemble a traditional sketch: You implement your \ident{setup} and your
\ident{loop} function; the former will be run once at the beginning and
the latter repeatedly.

\rtos{} on its own can't be compiled, there need to be an application.
\rtos{} is organized as a package which combines the \rtos{} source file
with some sample applications which are the test cases at the same time.
The source code of each sample application is held in a separate folder,
named tc\textless nn\textgreater. Any of these can be selected for
compilation. You may add more folders, holding the source code of your
\rtos{} application. A starting point of your application folder can be a
copy of any of the folders tc\textless nn\textgreater. The compilation
always is the same. Run the makefile, where the name of the folder (which
doesn't need to be tc\textless nn\textgreater) is an option of the
command line. See below for more.

A characteristic of \rtos{} is that the behavior of a task is not
predetermined or fixed at runtime. \rtos{} supports regular,
time-controlled tasks as well as purely event controlled ones. It supports
preemptive tasks and non-preemptive ones. Task scheduling can be done
cooperatively or time based, and round robin like time slices are also
possible. Moreover, many of these modes can be mixed. A task is not per-se
regular, its implementing code decides what happens and this can be
decided context or situation dependent. This flexibility is achieved by
the basic idea of having an event controlled scheduler, where typical RTOS
use cases are supported by providing according events, e.g.
absolute-point-in-time-reached. If the task's code decides to always wait
for the same absolute-point-in-time-reached event, then it becomes a
regular task. However, situation dependent the same task could decide to
wait for an application sent event -- and give up its regular behavior. In
many RTOS implementation the basic characteristic of a task is determined
at compile time, in \rtos{} this is done partly at compile time and partly
at runtime.


\chapter{How does \rtos{} work?}

In a traditional sketch, the function \ident{loop} defines all actions
which have to be excuted. The execution of the code is strictly
sequential. \ident{loop} may of course call any sub-routines, which may
call others, but this does not change the strictly sequential character of
the execution of the statements. Therefore it is difficult to execute
specific actions at specific points in time. For example toggle the state
of a LED every seconds. This might still be easy to do if your sketch does
nothing else -- see Arduino's standard example \ident{blink} --, but if
you're in the middle of a skecth, which e.g. transfers some data via the
USB port, it becomes ugly: You will have to merge some specific, the LED
serving statements, into your USB handling code. And the accuracy of the
yielded timing will not be perfect.

Imagine, you could simply write two sketches. The USB comunication stays
as it is but a second sketch, e.g. the sample sketch \ident{blink}, is
defined at the same time and will be executed, too. Now the USB code is no
longer spoiled with double-checking the state of the LED but nonetheless
the LED will blink as desired.

This actually is what \rtos{} offers. It's however no a complete sketch
but just a function -- which can of course be stored in a separate C
source file --, which is executed in parallel. Write two such functions,
make them so called tasks and you get what you want.

How would this work? The Arduino board continues to have a single main
CPU, which is solely available to execute any piece of code. The trick is
to use it alternatingly to proceed with the one task and then with the
other. If this switching between the tasks happens fast enough, than it's
the same as if both would run at the same time -- only with limited
execution speed.

Does alternating between the tasks happen regularly? It depends. Different
patterns of alternating between tasks are possible. The most simple is to
share the CPU in fixed portions between the tasks. The ratio can be
chosen. If we assume in our example that serving the USB port is more
challenging than flashing an LED, it would be reasonable to share the CPU
by 95:5 rather than by 50:50. This pattern is called Round Robin and fits
well if the tasks are completely independent of each other (as in our
example) and if all of them continuously require the CPU -- which is not
the case in our example!

Toggling the LED state can be done by permanently observing a watch and
switching the LED output when it reaches the next mark. A traditional
Arduino implementation of this strategy requires the CPU indeed permanent
and this is indeed how the sample sketch \ident{blink} is implemented. In
an RTOS you can do it better. Tell the system when you want to toggle the
LED state the next time and do nothing untill. Your task is inactive, does
not require the CPU any more and is nonetheless executed again exactely at
the desired point in time. Two advantages arise. Your task does barely
consume CPU power and the regularity of the execution is very good. This
pattern is the appropriate solution for our example. The LED is blinking
very regular, and nearly all of the CPU performance can still be spend on
the USB task, which therefore behaves the same way as if there was no
blinking LED at all.

The next pattern of sharing the CPU between different tasks is direct
coupling of tasks. By means of so called events a task can indicate a
specific situation to any other task, which will then react on this
situation. For example, the LED should not constantly blink. It is now
used to indicate the state of the USB communication by flashing a number
of times if a significant state change occurs. The number of flashes will
notify what happened. The LED task will now use an event to become active
and subsequently it'll use the execute-at-time pattern a number of times
to realize the sequence of flashes. The LED stays dark as long as the
event is not posted to the task. After the blink sequence the task will
again start to wait for the next ocurrance of the event. The active time of
this task is still close to zero: Every time it is executed it'll just use
a few statements to toggle the LED state and to inform the RTOS about the
next condition under which to become active again. The main task, which
implements the communication can proceed nearly as if there was no LED
task. There's however an extension to its implementation. In case of a
significant status change it has to indicate the number of according
flashes and to post the event. The former can be done by a write to a
global variable and the latter is a simple call of an \rtos{} API
function. The global variable is shared by both tasks, the LED task will
read it when being activated by the event.

If there are more tasks the scenario becomes more complicated, we need a
new term. If two tasks tell the RTOS the time they want to be activated
again, there is a certain chance, that it is the same time. In this
situation, if this time is reached, \rtos{} decides that both tasks are
due -- but only one of them can get the CPU, i.e. can be activated. Which
one is decided by priority. The priority of a task is a static,
predetermined property of a task. At compilation time, you will decide
which of tasks has the higher priority and which would get the CPU in the
mentioned situation. 

Similar: The tasks do not specify the same point in time but nearly the
same. Obviously, the task becoming due earlier will get the CPU. And when
the other one becomes due a bit later it might still desire to have the
CPU. Will it continue to have it? It depends again on the priority of the
tasks. If the later due task has the higher priority, it'll take over the
CPU from the earlier task. The earlier task is still due (as it didn't
return the CPU voluntarily so far) but no longer active. The later task is
both, due (it's point in time has reached) and active (it got the CPU).

When the active, later task tells \rtos{} to not longer need the CPU, the
earlier still due task will again get the CPU and continue to execute.

If a task tells the system to no longer require the CPU (by notifying:
"Continue my execution at/when") we say it is suspended. If it becomes due
again, we say it is resumed. If it is executed again, we say it is
activated.

There's always one and only one active task. What if all tasks in the
system did suspend themselves because they are waiting for a point in time
or an event? Now, there is a single task which must never suspend itself.
This task is called the idle task and \rtos{} can't be compiled without
such a task being present.\footnote{Caution, if the idle task would ever
try to suspend itself, a crash of the system would result.} The idle task
doesn't need to be defined in the code. \rtos{} uses the function
\ident{loop} as idle task. All the code in function \ident{loop} makes up
task idle. If you don't need an idle task (as all your code is time or
event controlled) just implement \ident{loop} as an empty function body.

Not implementing the idle task is however a waste of time. \rtos{} spends
all time in \ident{loop} when none of the other tasks is due. So if there
are any operations in your application which can or should be done
occasionally it's good practice to put them into the idle task. There's no
drawback, if any task needs the CPU, idle is just waiting until the task
has finished. The execution speed of task idle is directly determined by
the CPU consumption of the other tasks. Idle will never slow down the
tasks, but the tasks will slow down idle. Idle is a task of priority lower
than all other priorities in the system. Idle is a task which is never
suspended but always due and sometimes active.


\section{Implementation of \rtos' Scheduler}
\label{secScheduler}

The set of rules how to share the CPU between the different tasks is
called the scheduler. Actually, \rtos{} is nothing else than the
implementation of a scheduler.\footnote{From the world of personal
computers you will associate much more with the term operating system than
just a task scheduler. In fact, in this environment, the scheduler is just
the most important part of the operating system, therefore referred to as
kernel, but surrounded by tons of uitilities, mostly to support various
I/O operations. In the embedded world an RTOS typically doesn't offer
anything else than a scheduler and so does \rtos{}.} Understanding the
details of the decision rules implemented in \rtos{} is essential for
writing applications that behave as desired. (An RTOS can easily show
effects which are neither expected nor desired.) The rules of \rtos'
scheduler will become clear in the following documentation of its
implementation. Please refer to figure \ref{figRTuinOSScheduler} on page
\pageref{figRTuinOSScheduler}.

In \rtos{}, a task is represented by a task object. All objects are
statically allocated, there's no dynamic creation or
deletion.\footnote{Please, refer to section \ref{secOutlook} for more
detailed considerations about this.} The objects are configured in
Arduino's function \ident{setup} and stay unchanged from now (besides the
continuous update of the runtime information by the scheduler, see below).

\rtos{} manages all tasks in lists. There's one list per priority. All
tasks having a specific priority form a priority class and this class is
managed with the associated list. The number of different priorities is
determined at compile time by the application.

An additional list holds all tasks (of any priority) which are currently
suspended.

Within a task object there are a few members which express a condition
under which a suspended task is resumed. (These members are empty or in a
don't care state when a task is due or active.) More concrete, \rtos{}
knows about a limited number of distinct events\footnote{For good reasons
the events are implemented by bits in an unsigned integer word. Currently,
type \ident{uint16\_t} is used as it is a good trade off between number
of events and performance. A change to \ident{uint8\_t} or
\ident{uint32\_t} is possible but not trivial as assembler code is
affected. We thus have 16 such events.} and the mentioned condition is a
sub-set of these plus the following Boolean choice: will the task be
resumed as soon as any event of the sub-set is seen or does the task stay
suspended untill all events have been seen? Moreover, three of the known
events have a specific meaning; they are all timing related and have a
parameter of kind \emph{when}.

At system initialization time all tasks are put in state suspended.
Consequently, the initial resume condition is part of the task
initialization. Typically, this condition is weak, like "resume
immediately". However, a delayed resume or a resume by an application
event is also possible. Starting some tasks with differing delays may of
course be advantageous to avoid having too many regular tasks becoming due
all at the same time.


\section{Time based Events}
\label{secTimeBasedEvents}

The most relevant events of \rtos{} are absolute and relative time events.
An absolute time event means "resume task at given time". A relative time
event means "resume task after a given time span counted from now". You
see, the latter -- probably with time span zero -- is the most typical
initial resume condition for a task. It'll start immediately.

In the implementation a time event results from a system timer tic. The
core of the scheduler is a clock based interrupt. In \rtos{} this clock
has a default clock rate of about 2~ms, but this can be altered by the
application code. In the interrupt service routine (ISR), a variable
holding the absolute, current system time is incremented. (The rate of the
interrupt is the unit of all timing operations regardless of the actual
physical value.) The new value of the system time is compared against the
\emph{when} parameter of all suspended tasks which suspended with a
resume-at condition. If there's equality, the absolute time event is
notified to this task. For all tasks which had suspended with a
resume-after condition, the \emph{when} parameter of this condition is
decremented. If it reaches null, the desired suspend time has elapsed and
the relative time event is notified to the task.

The third time based event is available only if the system compiled with
round robin feature. Now a task may have a time slice defined. The time
slice is the maximum time the task may continuously be active. This event
is implemented directly, not as a bit, not as notification to the task. A
round robin task has a counter which is loaded with the time slice
duration at activation time. In each system timer tic it is decremented
for the one and only active task (if it is a round robin task and whatever
task it currently is). When the counter reaches null it is reloaded and
the task is immediately taken from the head of its due list and put at the
end of this list. This means the task stays due but will become inactive.
Another task, the new head of the list, is a more promising candidate for
the new, active task.

The next step is to check the conditions of all suspended tasks. For each
such task it is checked if its resume condition is fullfilled, i.e. if all
events it is waiting for have been posted to it meanwhile. If so, it is
taken out of the list of suspended tasks and placed at the end of the due
list of the priority class the task belongs to.

Now, after reordering the tasks in the several lists, the ISR finishes
with looking for the new, active task. The decision is easy. It loops
over all due lists, beginning with the highest priority. The head of the
first found non-empty list is the new, active task. If all due lists are
empty, the idle task is chosen. The seletced task is made active and the
ISR ends.


\section{Explicitly posted Events}
\label{secManualEvents}

Besides the system timer tic, the scheduler becomes active in two other
situations. The first one is the event explicitly posted by an application
task. \rtos{} knows a predefined number of general purpose events, which
can be posted by one task and which another task can wait for. The latter
task suspends itself and specifies the event as resume condition. Under
application determined conditions, the
former task calls the \rtos{} API function \ident{setEvent} and the latter
task will resume. 

In this situation it depends on the priorities of the two tasks how
\ident{setEvent} returns. If the event-setting task has the same or higher
priority \ident{setEvent} will immediately return like an ordinary
sub-routine. The other task becomes due but not active. If the
event-receiving task has the higher priority, \ident{setEvent} leads to
temporary inactivation of the calling task and will return only when this
task is activated again.

More in general, \ident{setEvent} is implemented as a software interrupt
(SWI) and behaves similar to the system timer ISR. It notifies the event
to all currently suspended tasks, which are waiting for it. The rest is
done exactely as the sytem timer ISR does. \ident{setEvent} checks the
resume condition of all suspended tasks. Those tasks the condition of
which is fullfilled are moved to the end of their due list. Then, the new
active task is selected. This might be the same or another task. The SWI
ends with continuing the new, active task.

As a matter of fact, a call of \ident{setEvent} will never make the
calling task undue (i.e. suspended), outermost inactive. This is the
reason, why \ident{setEvent} may even be called by the idle task.

Side note: There is a crosswise relationship between \ident{setEvent} and
the suspend commands. From the perspective of the task code switching
tasks appears as follows: The suspend function is invoked but it returns
out of the suspend command or call of \ident{setEvent} of another task
which became due meanwhile. If a task calls \ident{setEvent} it doesn't
need to return but could for example return out of the initially mentioned
suspend command.


\section{External Interrupts}
\label{secInterruptEvents}

The last situation where the scheduler gets active is an external
interrupt. (Here, the term external means "external to \rtos{}" as opposed
to "external to the \uC{}".) By compile switch, you can bind any true
interrupt to the \ident{setEvent} function. The ISR of the interrupt
source will call \ident{setEvent}. The event which is posted is no longer
a general purpose event but dedicated to this interrupt. 

The actions are exactely the same as described for \ident{setEvent} in
section \ref{secManualEvents}. Obviously, the ISR is asynchronous to the
task execution. If the posted event makes a task due which has a higher
priority than the interrupted task, the interrupted task is made inactive
(but it remains still due) and the other task will become active.

Typically, there will be such a task waiting for the event and having a
higher priority. Thus causing a task switch. There's only one use case for
this kind of scheduler invokation: The interrupt triggers a dedicated task
-- indirectly via the hidden call of \ident{setEvent} --, which actually
serves as interrupt handler, doing all sort of things which are needed by
the interrupt. This tasks will be implemented as an infinite
\ident{while}-loop, where the \ident{while}-condition is the suspend
command that waits for the interrupt event and where the body of the loop
is the actual handler of the interrupt.


\section{Return from a Suspend Command}
\label{secReturnFromSuspend}

An important detail of the implementation of \rtos{} is the way
information is passed back from the scheduler to the appliction code. The
direct interaction of this code with the scheduler is done with the
suspend commands and function \ident{setEvent} in the \rtos{} API.

\ident{setEvent} takes a parameter -- the set of events to be posted to
the suspended tasks -- but doesn't return anything. Here, the only
complexity to understand is, that it won't immediately return. It triggers
a scheduler act and won't return until the calling task is the due task
with highest priority. Which can be the case between immediately and never
in case of starvation.

The suspend commands take some parameters which specify the condition
under which the task will become due again, e.g. an absolute-time-event.
While the task is suspended, the different scheduler acts repeatedly double
check whether a sufficient set of events has been posted to the task (see
above). Each posted event is stored in the task object. As soon as the
posted set suffices, the task is moved from the suspended list to the end
of the due list of given priority class. From now on, since the task is no
longer suspended, no further events will be posted to this task and nor
will they be stored in the task object. Thus, the very set of events, which
made the task due is now frozen in the task object. When the task, which
is due now, becomes the active task again, the code flow of the task
returns from the suspend command it had initially invoked. At this
occasion, the stored, frozen set of events, which had made the task due is
returned as return value of the suspend command.

By simply evaluating the return code a task can react dependent on which
events it had made due. This is of particular interest if a task suspends
waiting for a combination of events. In practice this will be most often
the combination of an application event and a relative-time event, which
this way gets the meaning of a timeout. Obviously, the task needs to
behave differently whether it received the expected event or if there was
a timeout.

By the way, what has been said for the return from a suspend command also
holds true for the initial entry into a task function. Any task is
initialized in suspended state. The first time it is realeased the code
flow enters the task function. What's otherwise the return code of a
suspend command is now passed to the task function as function parameter.
This way the task knows by which condition it has been initially
activated.

\section{Summarizing the Scheduler Actions}

\incFigFile{RTuinOSScheduler}{Scheduler of \rtos}{0.8}

The different actions of the scheduler are depicted in figure
\ref{figRTuinOSScheduler}. The solid arrows indicate how task objects are
moved within and across the lists in different situations. The dashed
arrows represent pointers to particular task objects.

Under all circumstances, the active task -- highlighted in green -- is the
head of the top most non-empty list, i.e. the first due task in the order
of falling priority. Because of the particular importance of this task the
schedule permanently holds a pointer to this task object. One could say,
that maintaining this pointer actually is all the scheduler has to do.

The idle task object can be considered the only member of the due list of
lowest possible priority. This task is needed as fallback if no due task
is found in any of the priority classes and the scheduler has a constant
pointer to this specific task object. If \rtos{} is idle, both pointers have
the same value; they point to the idle task object.

Arrow 1 depicts the round robin action. Round robin activities can only
apply to the currently active task. If its time slice is elapsed, it is
taken from the head of the due list and placed at the end of this list.
Naturally -- and indicated by arrow 2 -- the next object in the list
becomes the new head of the list and will therefore be the new active
task.\footnote{This is not fully correct: If the round robin action takes
place in the due list which has not the highest priority, it can
occasionally happen that a task of higher priority becomes due -- and
active -- in the same timer tic.} If all tasks in this list are configured
to have time slices (and if there were no other resume conditions), the
list is cycled and all tasks get the CPU for a predefined amount of time.

Arrow 3 shows the effect of a suspend command. If the active tasks issues
such a command, it is moved from the head of its due list to the end of
the list of suspended tasks.\footnote{It's just for simplicity of the
implementation that we place it at the end. The list of suspended tasks is
not ordered; actually it is not a list but a pool of task objects.} Again,
arrow 2 shows how the next task in the due list will become the new head
and active task. However, if there was not second task in this list, the
head of a due list of lower priority would become the new active task. In
our figure, this could then be the head of priority list 1.

Arrows 4 and 5 show how a suspended task becomes due again. In any call of
either the system timer ISR or \ident{setEvent} all suspended tasks are
checked if their resume condition became true. If so, the task object is
moved from the list of suspended tasks to the end of their due list. The
due list a task belongs to is predetermined at compile time, when the task
priority is chosen. Actions 4 and 5 might appear in the same timer tic or
call of \ident{setEvent} or in different ones.

Arrow 5 shows the resume of a task of the highest known priority: Here, we
have an example where an event causes the interruption of a running task.
The due list of the resumed task was empty before this action. Thus the
resume creates a due task object of new maximum priority -- higher than
that of the task which was active so far. This less prior task is
inactivated. From the perspective of the task execution its code flow is
interrupted. Note, that the inactivated task object is not moved! It
remains the head of its due list. The task is inactive but still due and
still the first candidate for reactivation within its priority class.



\chapter{The API of \rtos}
\label{secAPI}

This chapter introduces the different functions of the application
programming interface (API) of \rtos. The intention is to explain the
meaning and use cases of the different API function, not all the details
of the function signatures. Please refer to the doxygen documentation
which directly builds on the C source code for details on function
parameters, return values, side effects, etc.


\section{Configuration of \rtos: rtos.config.template.h}

Building an \rtos{} application starts with the configuration of the
system. All elements of \rtos{} which require application dependent
configuration have been placed in the file \ident{rtos.config.template.h}.
This file is not part of the build, it's just a template for the file which
will actually by used. Copy the template to your application source code
and rename it to \ident{rtos.config.h}. This is the name it has to have as
this is the name used in the \ident{\#include} statements in the code.
Open the renamed file in a text editor and read the comments. You'll find
a number of \ident{\#define}'s which you need to adjust according to the
demands of your application. The number of tasks (besides the idle task)
you're going to use and the number of priority classes they belong to are
the most evident settings. You may enable the Round Robin strategy (by
default it's turned off), you may configure your application interrupts
and you may chose the resolution of the system timer. Please find a more
in detail discussion of some of these topics below and in the comments in
the source code.

\section{Initialization of \rtos: \ident{setup}}

The \rtos{} application starts with a call of \ident{setup}. This function
is a callback from the Arduino startup code (and the \rtos{} initialization
code at the same time) into your application. If you do not provide this
function the linker will report a problem and refuse to build the
executable. You may put all the initialization code of your application
here. And you need to place the specification of the tasks of your
application here. No other code location is possible to do this.


\section{Specification of Tasks: \ident{rtos\_initializeTask}}

From within \ident{setup} you have to call \ident{rtos\_initializeTask}
once per task. This function specifies the properties of a task. It's
important to know, that the specific \rtos{} interrupts have not been
started while \ident{setup} is executed. You may thus interfere with any
data objects owned by your tasks without consideration of race conditions
and access synchronization.

The most important thing to specify is the executable code of the task,
i.e. the task function. A specific function pointer type,
\ident{rtos\_taskFunction\_t}, has been defined for this purpose. Your
task function is a void function with a single parameter. This parameter
will pass the set of events to your task code, which made the task due the
very first time after system startup -- in the most typical use cases this
will be just one of the two system timer events and may be ignored by the
task code.

Typically, task functions cycle around (similar to the function
\ident{loop} in a traditional Arduino sketch). Some other RTOS offer a
task termination but \rtos{} doesn't. In \rtos{} a task needs to cycle
around and it must never end. If it ever did it would "return" to the reset
vector of the Arduino board and your application would start up again --
and probably stay in a loop of repeatedly doing so.

The stack area of the task is specified by a pointer to a reserved address
space in RAM and by the length of this reserved area. \emph{Reserved} means
that your application has to allocate the necessary memory. Since the
stack area can never be changed at runtime it doesn't make sense to
consider some dynamic allocation operations. Just define an array of
\ident{uint8\_t} and pass its address and size.

Caution: Reserved also means that the specified stack area must never be
touched by your application code.

If you configured \rtos{} to support the Round Robin strategy, you will
specify the duration of the time slices the task gets.

Another important part of the task specification is the initial resume
condition. It is specified exactely like at runtime and using the supend
command \ident{rtos\_waitForEvent}, please refer to section
\ref{secAPIWaitForEvent} for details. Your task will only start up if the
condition specified now becomes true.

\ident{rtos\_initializeTask} uses an index to identify which task object is
meant by the function call. The index has no particular meaning besides
being a kind of handle to the same task object when later using the
diagnostic functions \ident{rtos\_getTaskOverrunCounter} and
\ident{rtos\_getStackReserve}. The index needs to be lower than the number
of tasks but will not have an impact on the priority or order of execution
of the tasks.


\section{Initialization of Application Interrupts:
\ident{rtos\_enable\-IRQUser\textless nn\textgreater}}

Your application may configure \rtos{} to use its own interrupts which
trigger dedicated tasks. If you configure an interrupt a callback into
your application code is made as part of the system startup. The function
\ident{rtos\_enableIRQUser\textless nn\textgreater} is intended to
release the source of your interrupt \textless nn\textgreater. This
typically means to configure some hardware registers of a peripheral
device and to finally set the so called interrupt mask bit.

You must never try to do this as part of the general initialization
code in \ident{setup}: At this point in time the task, which are is
coupled to the interrupt is not ready to run and releasing the interrupt
now could cause unpredicted behavior of the service routine of your
interrupt.  

On the other hand, when \ident{rtos\_enableIRQUser\textless
nn\textgreater} is invoked, the \rtos{} system is up and running (besides
your interrupt) and all implications with respect to race conditions and
data access synchronization need to be considered.

Your application needs to enable the interrupt source but it doesn't have
to implement a service routine. This routine is part of the \rtos{}
implementation. Its standard action -- which can not be changed -- is to
post a dedicated event. Your application will surely specify a task of
high priority which cyclically waits for this event and implements the
actual interrupt service code.

The specification of the interrupt source is one detail of the \rtos{}
configuration made in \ident{rtos.config.h}.

Currently, the \rtos{} implements up to two application interrupts (i.e.
\textless nn\textgreater{} is either 01 or 02), but it's simple and
straight forward to extend the implementation to more interrupts if
required.

After return from the last callback \ident{rtos\_enableIRQUser\textless
nn\textgreater} your application is completely up and running.


\section{The idle Task: \ident{loop}}

Once the system is started it cyclically calls the void function
\ident{setup} which has to be implemented by your application. If you do
not provide this function the linker will report a problem and refuse to
build the executable.

The repeated call of \ident{loop} is the idle task of \rtos{}. This means
the execution of this code is done only if no other task requests the
CPU. The execution speed of \ident{loop} is directly dependent on the
activities of your tasks. Therefore it typically contains code which has
no real time constraints.

A typical use case of the idle task is to put some diagnostic code here.
For example, \rtos{} permits to double-check the usage of the stack areas.
(If a task would ever exceed its reserved stack area an immediate crash is
probable; which is a hard to find bug in the code.) This code is quite
expensive but when located in the idle task it doesn't matter at all. The
only impact of expensive code in the idle task is that the results will be
available somewhat later or less frequently. For a diagnostic function
this is typically uncritical.

\rtos{} supports typical use cases where always at least one task is due.
An example is a couple of tasks, all continuously running, and scheduled
by the Round Robin strategy. They are cyclically activated but never
suspended. In this situation \ident{loop} will never be called. However,
as a prerequiste of successful code linkage it's nonetheless required to
have it.

If no idle task is required or if there's no idle time left simply
implement \ident{loop} as an empty function.


\section{Suspend a Task: \ident{rtos\_waitForEvent}}
\label{secAPIWaitForEvent}

A task in \rtos{} stays due as long as it desires. If it has finished or
if it becomes dependent on the work result of some other task or on an
external event it will suspend itself voluntarily.

In a technical system, a task is often applied to do a regular operation,
e.g. read and process the input value from an analog-digital converter
every milli second.\footnote{In the \rtos{} default configuration the
system timer tic is about 2~ms; a one milli second task can't be
implemented without a configuration change.} Here, "finished" would mean
having performed this action. When the value of this mili second has been
processed, the task would suspend until the next milli second interval
begins. Suspending always includes a condition under which the suspended
state ends -- in our example it would be the absolute timer event and its
parameter \emph{when} would be set to the next milli second. From the
perspective of the task code flow, voluntarily suspending always means to
wait for something and doing nothing until. This explains the name of the
suspend function. With the view on the complete system, suspending means
to return the CPU and to pass it to other tasks, which currently don't
have to wait for whatever events.

In \rtos{} a task can suspend and wait
\begin{enumerate}
  \item until a point in time,
  \item for a while,
  \item until a set of events has been posted by other tasks (or a timeout
    has elapsed meanwhile),
  \item until at least one event out of a set has been posted by other
    tasks (or a timeout has elapsed meanwhile).\footnote{Actually, the
    first two conditions are special cases of the last two: The set of
    events to wait for just contains a timer event but nothing else.}
\end{enumerate}

The signature of the suspend command has a set of events as bit vector
(with up to 16 bits or events respectively) a Boolean operator (all events
required or any event releases the task) and a time parameter.

The time parameter doesn't care if no timer event is part of the set of
events. If the absolute timer event is in the set the time parameter has
the meaning \emph{when}. If the relative or delay timer event is in the
set the time parameter has the meaning \emph{after}. Consequently, it is
not allowed to have both timer events in the set.

\begin{lstlisting}[float, caption=Typical use case: regular task,
label=lstRegularTask, captionpos=b]
static void regularTask(uint16_t taskCondition)
{
#define MY_TASK_CYCLE_TIME 1 /* Unit is system timer tic, e.g. 1 ms */
    do
    {
      /* Actual task implementation: read ADC, process value... */
      ...
    }
    while(rtos_waitForEvent( RTOS_EVT_ABSOLUTE_TIMER
                           , /* waitForAllEvents */ false
                           , /* when */ MY_TASK_CYCLE_TIME
                           )
         );
} /* End of regularTask */
\end{lstlisting}

A bit specific is the parameter \emph{when} of the absolute timer. The
most typical use case of the absolute timer event is the implementation of
a regular task; in our example above a task, which is activated every
milli second. See listing \ref{lstRegularTask}: The implementation will
place the action into an infinite loop. The \ident{while} condition at the
end of the loop will be a call of \ident{rtos\_waitForEvent}, addressing
to the absolute timer event. In each loop the next milli second is passed
as parameter \emph{when}. This would require an accumulating variable in
the implementation, which is updated in every loop. To avoid this, the
parameter \emph{when} is defined to be a difference, the difference to the
last recent refernce to the absolute timer. This would mean in our typical
use case, that parameter \emph{when} becomes a constant. In every loop,
the parameter simply is 1~ms in the call of \ident{rtos\_waitForEvent}.


\subsection{\ident{rtos\_suspendTaskTillTime}}

To further support the typical use case of regular tasks, there's an
abbreviation of the call of \ident{rtos\_waitForEvent} as sketched in
listing \ref{lstRegularTask}. Instead of calling
\ident{rtos\_waitForEvent} one can call \ident{rtos\_suspendTaskTillTime}.
The only parameter of the function is the parameter \emph{when}.

\ident{rtos\_suspendTaskTillTime} is implemented as preprocessor macro, so
there's no difference in comparison to directly using
\ident{rtos\_waitForEvent} but the readability of the code.


\subsection{\ident{rtos\_delay}}

Another abbreviated call of \ident{rtos\_waitForEvent} supports the
condition "wait for a while" (but not for any specific event). You may use
the preprocessor macro \ident{rtos\_delay} for this. The only macro
parameter is the timer parameter, which specifies the delay time (or the
time to stay supended respectively).

There's no difference in comparison to directly using
\ident{rtos\_waitForEvent} except for the readability of the code.


\section{Awake suspended Tasks: \ident{rtos\_setEvent}}

Timer events are entirely managed by the system, all other events will
only occur if they are posted by the application code. This can be done
either by application interrupts or by invoking the API function
\ident{rtos\_setEvent}.

The only parameter of the function is the set of events to be posted,
implemented as a bit vector of 16 bits. Neither the timer events nor the
external interrupt events must be posted, there remain (dependent on the
configuration of \rtos{}) twelve to fourteen events, which are directly
handled by the application task code.

There are predefined names of the available event, please refer to
\refRTOSH. Regardless, you may also define your own, suitable names.

A typical use case of application handled events are producer consumer
models. One task prepares some data and signals availability to the data
consuming task by setting an event. Obviously, the consumer starts with
waiting for this event.

Be aware, an event is broadcasted only to the currently suspended tasks
and is not stored besides that. If a task suspends shortly after another
has posted an event, the suspend task will never receive this event and
may stay suspended forever.


\section{Data access: \ident{rtos\_enter/leaveCriticalSection}}

In all relevant use cases, tasks will share some data. Some tasks will
produce data, others will read it. If your application has tasks of
different priority, this becomes a matter. Except for a few trivial
examples like reading or writing a one Byte word, all data access is not
atomic, i.e. can be interrupted by any system interrupt. The software has
to anticipate that this is an \rtos{} system timer interrupt or an \rtos{}
external application interrupt which can easily cause a task switch. A
task can be in-activated while it is busy updating the data and another
task can continue operating on the same, half way completed data. The
results are unpredictable and surely wrong. Be aware, even an atomic
looking operation like \verb$++u;$, where \ident{u} is a of type
\ident{uint8\_t} is unsafe requires protection.

The pair of API functions \ident{rtos\_enterCriticalSection} and
\ident{rtos\_leaveCriticalSection} makes any portion of code which is
enclosed atomic -- and thus safe with respect to shared access from
different tasks.

\ident{rtos\_enterCriticalSection} simply inhibits all those interrupts,
which can cause a task switch and \ident{rtos\_leaveCriticalSection}
re-enables all those interrupts.

The function do not save and restore the interrupt-inhibit state. After
any \ident{rtos\_leaveCriticalSection}, all interrupts are surely enabled.
Therefore, the pairwise calls of the functions can't be nested. The code
in the outer pairs wouldn't be protected.

The pair of functions \ident{cli} and \ident{sei} from the AVR library
nearly has the same meaning and can also be used to make data access
operations atomic. The difference is that they inhibit all interrupts. The
responsiveness of the system could be somewhat degraded without need, e.g.
the Arduino time functions like \ident{delay} or \ident{millis} would
suffer. On the other hand, these twoo functions are a bit cheaper. We
suggest to use them if the protected code sequence is rather short, e.g.
just one or a few simple assignments and to use
\ident{rtos\_enter/leaveCriticalSection} otherwise.

In \rtos{} a task of same or lower priority will never become active while
a task of same or higher priority is running and doesn't suspend itself
voluntarily. Therefore, a task of same or higher priority doesn't need
atomic operations to access data it shares with other tasks of same or lower
priority, but vice versa the access code to the same data of course needs
to be protected.

In cooperative systems task generally don't need to protect their access
to shared data as tasks will never be interrupted at unforeseeable (and
undesirable) points in time.

To summarize, 
\begin{enumerate}
  \item always put your data access code into a pair of protective
    functions if the task shares this data or parts of it with at least
    one other task of higher priority,
  \item use \ident{rtos\_enter/leaveCriticalSection} as pair of protective
    functions if the access code is complex,
  \item use \ident{cli}/\ident{sei} as pair of protective functions if the
    access code is trivial.
\end{enumerate}


\section{Diagnosis: \ident{rtos\_getTaskOverrunCounter}}

Each task has a built-in overrun counter. The meaning of this counter is
well defined only for regular tasks. These tasks want to become due at
fixed points in time. If too many tasks have to much to do it may happen
that it is not possible to make a task due at the desired point in time.
This is then a task overrun event. It is counted internally. This function
reads the current value of the counter for a given task.

Using this function, the application can write some self-diagnostic code.
However, if such events are seen, there's barely anything to do at
runtime. Evaluating the counters should be considered a kind of debug
information, a hint at development and testing time that the
implementation is still insufficient and needs changes.


\section{Diagnosis: \ident{rtos\_getStackReserve}}

A simple algorithm determines the usage of the task tasks. (In any RTOS,
each task has its own, dedicated stack.) The size of the stacks is
predetermined at runtime and determining the stack size at runtime is just
a development tool. If the stack of any task is exhausted and exceeded the
system will surely crash and the casue of the crash will be hard to find.
Allocating the stack sizes much too large is too expensive with respect to
RAM usage. Therefore, applying this function, you can keep an eye on the
actual stack usage during development and testing phase and reduce the
allocation to a reasonable value.

There are two pitfalls. The algorithm searches the stack area for a
specific byte pattern the area has been initailized with, and which is
typically not written into the stack at runtime. However, it could be
written at runtime with a low but significant probability. As a result,
the actual stack usage can be one byte more than computed with a
probability, which must not be neglected. It's however much less probable
that two such bytes will be written subsequently into the stack at runtime
-- the probability that the computed number of bytes is too little by two
is much less. And so forth. If you add a number of five Byte to the
computed stack usage the remaining probabilty that this is less than the
actual stack usage is negligible.

The current stack usage increases suddenly by about 35 Byte in the
instance of a system interrupt (the CPU context of the interrupted task is
saved onto the stack of this task). \ident{rtos\_getStackReserve} returns
the maximum stack usage so far (actually is returns the inverse value, the
\emph{reserve}, but this is equivalent). This is a useful value once your
testing code ran through all code paths, particularly through the deepest
nested sub-functions. You can ensure this by dedicated test routines. But
can you also be sure that a system interrupt occured in the very instance of
being inside the deepest nested sub-routine? If not, it'll surely happen
later and another 35 Byte of stack will be consumed. It's good practice to
add another 35 Byte to the computed stack.

Summarizing, you should add 40 Byte to the computed stack usage before
reducing the stack size to the really needed value.


\chapter{Typical Use Cases}

Traditional, regular tasks, cooperative tasking, consumer-producer model,
interrupt tasks
No suspend: Round Robin of decoupled tasks


\chapter{How to write an Application}
\label{secHowToWriteApp}

Copy a test case folder. Explain all settings in rtos.config.h which have
to be touched.

Why is \rtos{} a C source file? Will we ever change this file? Yes for
development of \rtos{} itself but never to write an application!

Explain how to use the makefile. Hint: Switch of application/TC always
requires a clean as the configuration of rtos.c (number of tasks) differs.

DEBUG compilation and particularly ASSERT requires initialization of Serial


\subsection{Usage of Arduino Libraries}

Timing, static data, single instance of device. Mutual exclusion for
single instance


\subsection{Configurating the System Timer}

Discussion of how many bits are required. 


\chapter{Outlook}
\label{secOutlook}

The lists which hold the due tasks are implemented as arrays of fixed
length. All priority classes use a list of identical length. This has been
decided jsut because of the limitations of constant compile time
expressions and macros. The code would run without any change if the
rectangular array holding all lists would be replaced by a linear array of
pointer, which are initialized to point to class-individual linear arrays.
This construction would save RAM space in applications which have priority
classes of significantly differing size. Besides some saved RAM and the
less transparent initialization on application side\footnote{We don't like
to do dynamic initialization using a loop and a call of \ident{malloc}
inside in an embbeded environment. This would probably consume RAM space
on the heap in the same magnitude than what can be saved by the changed
layout of the data structure.} there's absolutely no difference of
both approaches and therefore the importance for this change is not high
enough to actually do it.

Currently, the idle task is described by an additional element in the task
array -- although it lacks most of the properties of a true task.
Actually, only the stack pointer save location and the (always zero)
vector of received events are in use. If the task object is split into two
such objects (holding the properties of all tasks and holding the
properties of true tasks only) some currently wasted bytes of RAM could be
saved.

The priority of a task could be switched at runtime if only the arrays are
large enough -- but this is anyway in the responsibility of the
application. (Condensed array implementation by pointers to individual
arrays became impossible in this scenario.) The implementation is simple
as it was close to existing code. The API function would be implemented as
software interrupt similar to the suspend commands. The active task would
be taken out of its class list and put at the end of the targeted class
list. The list lengths would be adapted accordingly. Then the normal step
of looking for the now most due task and making this the active one would
end the operation. \ident{setEvent} would probably be the best fitting
starting point of the implementation. This idea has not been implemented
as we don't see a use case for it.

Currently, the round robin time (including round robin mode on/off by
setting the time to 0) is predetermined at compile time -- but without any
technical need. It would easily possbible to change it by API call at
runtime. If we specify that a change won't affect the running time slice
it's very easy as the call of this function won't cause a task switch. A
software interrupt is not required, just touch the reload value of the
round robin counter.

There's no strong technical reason, why a task should not end. At the
moment the return address of a task function is the reset address of the
\uC{}. By modifying \ident{prepareTaskStack} it could become any other
address, e.g. the address of a function implemented similar to the suspend
commands. It would not put active the task into the list of suspended
tasks but in a new list of terminated tasks. This list is required as task
termination makes sense only if there's also a chance to create new ones.
The terminated task list would be the free-list of objects to reuse
whenever a new task is created at runtime.

Starting a new task at runtime would mean to let \ident{prepareTaskStack}
operate on a currently unused task object and to place the object in a
critical section into the list of suspended tasks. As currently, the
application is responsible for obyeing the size of the lists, in
particular if there's still room in the priority class.

Since we do not want to introduce dynamic memory allocation into the
application, any started task needs to be preconfigured. It has to be
decided if under these circumstances terminating/restarting a task has a
big advantage against just suspending permanently existing tasks.


\chapter{Collected Notes}

What is real time? Round Robin isn't. Jitter is accepted.

Timer: Is also resolution for delay and waitForEvent. If runtime optimal
(tic=fastest task time) than the fastest task has no chance to use other
delay than with limit to next regular task due time

The context switch may enable global interrupts first to not block high
priority interrupts. How to do and rules: Those ISRs must not trigger an
event which could result in a context switch (otherwise danger of stack
overflow in case of many sub-sequent task switches - but is it really if
2ms timer is only source of undetermined task switch?). Possible e.g. for
I/O handling with high responsiveness. Initialization and feedback can
only be done in a normal task not using the RTOS events.
  Double check if timer0 used by Arduino for millis etc. is an example.

The matter "when to disable/enable IRQ" should become an own topic in the
manual.

Explain cli/sei versus enterLeaveCriticalSection: All interrupts are
locked or only the task switch causing one.

Tasks can be interrupted only by tasks of higher priority. If round robin
is implemented and activated, it may also be interrupted by tasks of same
priority class. Those and only those tasks which share data with tasks
which may interrupt them because of the rules before, need to apply calls
of enter/leaveCriticalSection to protect the access to this data.

Enter/leaveCriticalSection is part of the code adaptations when binding a
new interrupt to an existing event. ECS/LCS need to lock all interrupts
which possibly can cause a task switch - but no other interrupts.
  Example: producer-consumer model ADC: Free-running mode, interrupt on
conversion completed sets event. Task waiting for event with high priority
will read the result and switch the channel. It'll than do the
anti-aliasing filtering. The time-triggered slow task reads the filter
output (and does implicitly do the downsampling this way).

Idle task may set an event but may not suspend in any way. If it sets an
event it can be sure that the awaked task has completed all related data
processing until idle gets reactivated again. Therefore, a
producer-consumer solution can be implemented with a single event as
access synchronization, no ECS/LCS needs to be applied. (Explain why and
generalize this idea to any pair of tasks of different priority classes.)

Consumer/producer with bi-directional synchronization however only on same
prio level. Otherwise we would need a postAndWaitFor operation. Set an
event and wait for the same or others. However: What is a real use case?
Why then not using a single task and sub-routines?

Compiler assumptions/prerequisites:
  naked, no prologue
  no local data in stack frame
  parameters in registers, without using stack frame: Problem with .O0 (http://lists.gnu.org/archive/html/avr-gcc-list/2012-08/msg00014.html)
  r24/r25 for return value 

Look for comment blocks in source code.

    Idea: A task needs to return a value at restore context when and only when it is
    activated the very first time after it had been suspended. (It will not return a value
    if it is activated from an interruption by another task of higher priority or because
    of a round-robin cycle.) Prove: The
    task gets suspended only on its own demand by calling one of the suspend functions
    and these functions have a return value. (Exception is task initialization: if we set
    r24/25 now, it'll become the function parameter. This inhibits a general purpose
    parameter but generalizes the start of a task: It can be started by any combination of
    events and its parameter tells how it actually was.)
      Thus: The activation will check the event vector. If not null the task is awaked,
    thus activated the first time after suspension. Now the event vector is returned and
    reset in the task array. If we find event vector equal to null, the task is activated
    for continuation, not after a suspend, and the completed pushed context is restored.
      In the first case, we will overwrite r24/25 with the return value and this can be
    done easiest by pushing the values after switching the SP and then doing a complete pop
    context. (Required change: r24/25 is the topmost entry in the pushed context.)
    Consequently, the switch functions and the task stack preparation would not push r24/25
    as part of the context.
      Going back to a context:
    If task ID stays same: do not switch SP, pop all, reti.
    If task ID changes:
        If eventVec of new task is null
            Switch SP, pop all, reti
        If eventVec of new task is not null
            Switch SP, push eventVec, clear eventVec, pop all, reti

Why do we not have type \ident{eventMask\_t} and leave it to the user if he needs
8, 16 or 32 events? The complexity of stack handling for passing the event
mask parameters hence and force would require quite complex \#if switches
which would make the code ugly. It's however basically possible without
conceptual changes.

Explain the flag-meaning of \ident{task.postedEventVec}, how it tracks from which
state a task comes from and how it determines what the return in r24/25 to
the caller

Producer-Consumer patterns like
\begin{lstlisting}[float, caption=Deadlock situation in a producer/consumer implementation,
label=lstProducerConsumer, captionpos=b]
taskProducer()
{
    while(rtos_waitForEvent(myEvtStartToProduce))
    {
        /* Generate the shared, produced data. */
        ...

        /* Signal "data available". */
        rtos_setEvent(myEvtStartToConsume);
    }
}

taskConsumer()
{
    while(rtos_waitForEvent(myEvtStartToComsume))
    {
        /* Evaluate the shared, produced data. */
        ...

        /* Signal termination. */
        rtos_setEvent(myEvtStartToProduce);
    }
}
\end{lstlisting}
will run only if both tasks have same priority and no round robin characteristics.
Otherwise we'd need an atomic combination of setting events and suspending with waiting for
other events. If the consumer had e.g. a higher priority as the producer, it could be
started in the instance the producer posts the event "data available". When it would post
the event "start next production cycle", this event would be lost as the producer is not
yet listening to this event. At this time the producer's program counter still points into
the middle of its setEvent method - the lower priority task had no chance to reach the call
of \ident{rtos\_waitForEvent} yet.

In practice we often have a loose coupling between consumer and producer. Consuming the
data is considered fast in comparison to the production cycle and backward feedback is not
implemented. Principally, data can be lost but the probability is low enough to neglect
this risk. An example can be an interrupt driven I/O operation. Each time the ADC has
completed a conversion is sets an event and a task of high priority reads the data and
processes it:
\begin{lstlisting}[float, caption=Usage of application interrupts,
label=lstSampleISRForADC, captionpos=b]
taskReadADC()
{
    while(rtos_waitForEvent(myEvtADCConversionReady))
    {
        /* The ADC is read and retriggered for the next conversion. */
        x = readADC();
        
        /* The read value is low pass filtered and put into a global variable from where it
           is processed by another, slower, regular task. The slower task is of lower
           priority, therefore we need no mutex operation here in this task. */
        globalY = antiAliasFilter(x);
    }        
}
\end{lstlisting}


