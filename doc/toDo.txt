Test case for AND combination of events but a timeout at the same time.
Has been implemented in r233 but never been tested at that time.

Implement get/setRoundRobin?
  Abgelehnt. Unwichtig, trivial und verstellt nur den ansonsten schlanken
und schönen Code.

EnterLeaveCriticalSection: Try without cli/sei but only TIMER2). Use tc07
  Done: cli/sei is essential, test case fails otherwise

Manual: 3.8, API, enter/leaveCS: sei/cli will disable delay, but not
delayMicroseconds. e/lCS would be okay with both

Mention the system load estimation in the manual
  Mentioned in the readMe of release 2.

Mention false task overrun recognitions in manual. The C comments
reference it but it doesn't contain this issue yet. Furthermore, the API
documentation of suspendTillTime and waitForEvent should mention this as a
true problem appears if tiCycle is > 127: False task overrun recognitions
lead to too soon activation. Another location where to place a hint is the
type-of-timer discussion in config.h
  Done in manual, section 4.3.3
  Limit 127 corrected in rtos.config.h, explanations given
  Done

R2:

rtos_setEvent could become sendEvent, the old name is retained by macro.
(sendEvent could fit better to mutex and semaphore.) 
  Done in
file:///M:/SVNMainRepository/Arduino/RTuinOS/branches/RTuinOS_refactoringPostEvents,
r399.

Manual: Serial.print blocks if buffer full. If a task writes more bytes
than space in the buffer it blocks in CPU wait cycles and the CPU load is
directly determinated by the Baud rate. If a regular task writes less than
fits into the buffer it isn't blocked at all as the buffer will probably
be flushed until its next activation. Now the CPU is independent of the
Baud rate

Consider to place gsl into the RTOS directory. It's proven to be valid and
useful meanwhile. Adapt doxyfile accordingly
  Done.

Take relevant samples into the doxygen manual
  Done.

Makefile: -DARDUINO=101 should surely become 105, double-check
  Done.

Compile C files with avr-gcc. Already known issues: bool is undefined and
_pActiveTask can't be dynamically initialized to be _pIdleTask.
  July 7, 13: See SVN branch
file:///M:/SVNMainRepository/Arduino/RTuinOS/branches/RTuinOS_compileWithGCC:
Widely done but it's unclear, if it pays off and if it is advantageous.
Findings:
  bool can be replace by boolean. This is known by typedef in the Arduino
environment. Ugly as it should be boolean_t for consistency reasons. But
will we really introduce such a new typedef?
  The test case files either need to be renamed into *.cpp or all
references to Serial need to be replaced by printf, using the stdout
module.
  The ASSERT macro must no longer use Serial, but needs to use printf.
This makes RTuinOS dependent on the module stdout. On the one hand it's
elegant to hide the initialization of stdout in main, thus to have printf
always available just like that, but on the other hand should a system like
RTuinOS not deal with things like these. True RTuinOS application won't
use stdio; this is just for demonstration, sample code and debugging. The
trade off is undecided.

tc06: The config setting RTOS_OVERRUN_TASK_IS_IMMEDIATELY_DUE should be
RTOS_FEATURE_OFF and the meaning/why should be documented. Obviously, the
test case doesn't do what it is expected to. If we change the feature, the
anticipated timing changes and an assertion fires. Make this a clearer,
better documented test case.

tc12: The reported timing looks like a temporary task overrun for the
producer (while it waits for the Serial mutex from the consumer, which
reports the entire list of queued elements). Task time is alright in mean.
Is the not-recognition of the overrun a failure or an new effect of the
already know weaknesses of the counter?

Event macros in rtos.h: They should support up to 14 Mutexes if no
application interrupt is defined. Use more #if to do.

New test case: Only semaphores and no 1 is demanded, 0 should be got also:
Bug detected in trunk, but already fixed in branch
RTuinOS_refactoringPostEvents.