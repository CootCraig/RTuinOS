Test case for AND combination of events but a timeout at the same time.
Has been implemented in r233 but never been tested at that time.
  Done, used and double-checked e.g. in tc15

Manual: 3.8, API, enter/leaveCS: sei/cli will disable delay, but not
delayMicroseconds. e/lCS would be okay with both

Mention the system load estimation in the manual
  Mentioned in the readMe of release 2.
  Done in manual also, new section in API chapter, see r405

R2:

Manual: Serial.print blocks if buffer full. If a task writes more bytes
than space in the buffer it blocks in CPU wait cycles and the CPU load is
directly determinated by the Baud rate. If a regular task writes less than
fits into the buffer it isn't blocked at all as the buffer will probably
be flushed until its next activation. Now the CPU is independent of the
Baud rate

Compile C files with avr-gcc. Already known issues: bool is undefined and
_pActiveTask can't be dynamically initialized to be _pIdleTask.
  July 7, 13: See SVN branch
file:///M:/SVNMainRepository/Arduino/RTuinOS/branches/RTuinOS_compileWithGCC:
Widely done but it's unclear, if it pays off and if it is advantageous.
Findings:
  bool can be replace by boolean. This is known by typedef in the Arduino
environment. Ugly as it should be boolean_t for consistency reasons. But
will we really introduce such a new typedef?
  The test case files either need to be renamed into *.cpp or all
references to Serial need to be replaced by printf, using the stdout
module.
  The ASSERT macro must no longer use Serial, but needs to use printf.
This makes RTuinOS dependent on the module stdout. On the one hand it's
elegant to hide the initialization of stdout in main, thus to have printf
always available just like that, but on the other hand should a system like
RTuinOS not deal with things like these. True RTuinOS application won't
use stdio; this is just for demonstration, sample code and debugging. The
trade off is undecided.

tc12: The reported timing looks like a temporary task overrun for the
producer (while it waits for the Serial mutex from the consumer, which
reports the entire list of queued elements). Task time is alright in mean.
Is the not-recognition of the overrun a failure or an new effect of the
already know weaknesses of the counter?

Event macros in rtos.h: They should support up to 14 Mutexes if no
application interrupt is defined. Use more #if to do.

New test case: Only semaphores and no 1 is demanded, 0 should be got also:
Bug detected in trunk, but already fixed in branch
RTuinOS_refactoringPostEvents.
  Done, tc15, see r408