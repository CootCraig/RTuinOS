Test case for AND combination of events but a timeout at the same time.
Has been implemented in r233 but never been tested at that time.

Implement get/setRoundRobin?

Timer ISR: onTimerTic, nur jedes n-te Mal. Bei Standardeinstellung 1 kein
Overhead, da Code komplett ausgeblendet bleibt. Manual
#define PRESCALER.
#if PRESCALER != 1
    static uint8_t cnt = 0;
#endif
  Abgelehnt: Macht wenig Sinn, weil mehrfache Interrupts bewusst ohne
Taskwechsel nur Performancefresser sind. Dann lieber die Hardware
langsamer programmieren.

EnterLeaveCriticalSection: Try without cli/sei but only TIMER2). Use tc07
  Done: cli/sei is essential, test case fails otherwise

Manual: 3.8, API, enter/leaveCS: sei/cli will disable delay, but not
delayMicroseconds. e/lCS would be okay with both

TC05: T0C0: Documentation and implementation differ. Timeout event is
commented out while value is still set. The task cycle time is documented
to be slow while it is set very fast. T1C0: cycle time is documented
different to implementation. The triggered T0C1 has a very long timeout to
wait for each trigger. Should become much sharper
  All done

TC10: Document the observations
  Done

Mention the system load estimation in the manual

Mention false task overrun recognitions in manual. The C comments
reference it but it doesn't contain this issue yet. Furthermore, the API
documentation of suspendTillTime and waitForEvent should mention this as a
true problem appears if tiCycle is > 127: False task overrun recognitions
lead to too soon activation. ANother location where to place a hint is the
type-of-timer discussion in config.h

R2:

rtos_setEvent could become sendEvent, the old name is retained by macro.
(sendEvent could fit better to mutex and semaphore.) 

Manual: Serial.print blocks if buffer full. If a task writes more bytes
than space in the buffer it blocks in CPU wait cycles and the CPU load is
directly determinated by the Baud rate. If a regular task writes less than
fits into the buffer it isn't blocked at all as the buffer will probably
be flushed until its next activation. Now the CPU is independent of the
Baud rate

Consider to place gsl into the RTOS directory. It's proven to be valid and
useful meanwhile. Adapt doxyfile accordingly

Take relevant samples into the doxygen manual